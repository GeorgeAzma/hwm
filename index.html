<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensors</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="utils.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div id="dashboard-container">
        <div class="glass-pane sensor-group cpu">
            <h2 id="cpu">CPU</h2>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-microchip sensor-icon"></i>
                    <span class="sensor-label">Load</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-total-load"></span><span class="sensor-unit">%</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="cpu-total-load-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-tachometer-alt sensor-icon"></i>
                    <span class="sensor-label">Core Max Load</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-max-load"></span><span class="sensor-unit">%</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="cpu-max-load-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-bolt sensor-icon"></i>
                    <span class="sensor-label">Package Power</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-package-power"></span><span class="sensor-unit">W</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-bolt sensor-icon"></i>
                    <span class="sensor-label">Cores Power</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-cores-power"></span><span class="sensor-unit">W</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-bolt sensor-icon"></i>
                    <span class="sensor-label">CPU Core</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-core-voltage"></span><span class="sensor-unit">V</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="glass-pane sensor-group cpu">
            <h2>CPU Temps</h2>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-thermometer-half sensor-icon"></i>
                    <span class="sensor-label">Package</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-package-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="cpu-package-temp-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-thermometer-full sensor-icon"></i>
                    <span class="sensor-label">Core Max</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-core-max-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="cpu-core-max-temp-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-thermometer-quarter sensor-icon"></i>
                    <span class="sensor-label">Core Avg</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-core-avg-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="cpu-core-avg-temp-bar"></div>
                </div>
            </div>
            <div class="" id="cpu-core-temps-section">
                <div class="cpu-graph-container temps-graph">
                </div>
            </div>
        </div>
        <div class="glass-pane sensor-group cpu" id="cpu-core-loads-section">
            <h2>Core Load</h2>
            <div class="cpu-graph-container loads-graph">
            </div>
        </div>
        <div class="glass-pane sensor-group cpu" id="cpu-core-clocks-section">
            <h2>Core Clock</h2>
            <div class="cpu-graph-container clocks-graph">
            </div>
        </div>
        <div class="glass-pane sensor-group gpu">
            <h2>GPU</h2>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-gamepad sensor-icon"></i>
                    <span class="sensor-label">Load</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-core-load"></span><span class="sensor-unit">%</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="gpu-core-load-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-hdd sensor-icon"></i>
                    <span class="sensor-label">VRAM</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-vram-used"></span><span class="sensor-unit">GB</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="gpu-vram-used-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-thermometer-half sensor-icon"></i>
                    <span class="sensor-label">Core Temp</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-core-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="gpu-core-temp-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-fire sensor-icon"></i>
                    <span class="sensor-label">Hot Spot</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-hotspot-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="gpu-hotspot-temp-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-microchip sensor-icon"></i>
                    <span class="sensor-label">Mem Temp</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-memory-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="gpu-memory-temp-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-bolt sensor-icon"></i>
                    <span class="sensor-label">Power</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-power"></span><span class="sensor-unit">W</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="gpu-power-utilization-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-ethernet sensor-icon"></i>
                    <span class="sensor-label">PCIe Rx</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-pcie-rx"></span><span class="sensor-unit">MB/s</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-ethernet sensor-icon"></i>
                    <span class="sensor-label">PCIe Tx</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-pcie-tx"></span><span class="sensor-unit">MB/s</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="glass-pane sensor-group ram">
            <h2>Memory</h2>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-memory sensor-icon"></i>
                    <span class="sensor-label">RAM</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="ram"></span><span class="sensor-unit">GB</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="ram-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-database sensor-icon"></i>
                    <span class="sensor-label">Virtual</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="virtual-ram"></span><span class="sensor-unit">GB</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="virtual-ram-bar"></div>
                </div>
            </div>
        </div>
        <div class="glass-pane sensor-group fans" id="fans-section">
            <h2>Fans</h2>
        </div>
        <div class="glass-pane sensor-group network">
            <h2>Network</h2>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-arrow-down sensor-icon"></i>
                    <span class="sensor-label">Download</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="wifi-download"></span><span class="sensor-unit">MB/s</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-arrow-up sensor-icon"></i>
                    <span class="sensor-label">Upload</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="wifi-upload"></span><span class="sensor-unit">MB/s</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-download sensor-icon"></i>
                    <span class="sensor-label">Total Down</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="wifi-total-download"></span><span class="sensor-unit">GB</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-upload sensor-icon"></i>
                    <span class="sensor-label">Total Up</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="wifi-total-upload"></span><span class="sensor-unit">GB</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>        function createCard(icon, label, valueId, unit, barId = null) {
            return `<div class="sensor-card">
                <div class="icon-value">
                    <i class="${icon} sensor-icon"></i>
                    <span class="sensor-label">${label}</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="${valueId}"></span><span class="sensor-unit">${unit}</span>
                    </div>
                </div>` + (barId ? `
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="${barId}"></div>
                </div>
            </div>` : `
            </div>`);
        } const flatSensorData = {};
        const domElementCache = new Map(); let headersInitialized = false;
        const hardwareNames = {
            cpu: 'CPU',
            gpu: 'GPU',
            memory: 'Memory',
            network: 'Network',
            storage: 'Storage'
        };

        function getCachedElement(id) {
            if (!domElementCache.has(id)) {
                domElementCache.set(id, document.getElementById(id));
            }
            return domElementCache.get(id);
        }
        function flattenSensors(node, clearFirst = false) {
            if (clearFirst) {
                for (const key in flatSensorData)
                    delete flatSensorData[key];
            }

            if (node.SensorId) {
                flatSensorData[node.SensorId] = node;
            }
            if (node.Children) {
                node.Children.forEach(child => flattenSensors(child, false));
            }
        }
        function extractHardwareNames(data) {
            function findHardwareByType(node) {
                if (node.Type) {
                    if (node.Type === 'Cpu' && node.Text) {
                        hardwareNames.cpu = node.Text.replace(/Intel|AMD|Core|Ryzen|Processor/ig, '').trim();
                    }
                    else if ((node.Type === 'GpuNvidia' || node.Type === 'GpuAmd' || node.Type === 'Gpu') && node.Text) {
                        hardwareNames.gpu = node.Text.replace(/NVIDIA|GeForce|AMD|Radeon/ig, '').trim();
                    }
                    else if (node.Type === 'Memory' && node.Text) {
                        hardwareNames.memory = node.Text.replace(/Generic Memory/ig, 'Memory').trim();
                    }
                    else if (node.Type === 'Network' && node.Text) {
                        hardwareNames.network = node.Text;
                    }
                    else if (node.Type === 'Storage' && node.Text) {
                        hardwareNames.storage = node.Text;
                    }
                }

                if (node.Children) {
                    node.Children.forEach(child => findHardwareByType(child));
                }
            }

            findHardwareByType(data);
        }
        function updateSectionHeaders() {
            if (headersInitialized) return;

            const cpu = document.getElementById('cpu'); cpu.textContent = hardwareNames.cpu;

            const gpuSection = document.querySelector('.sensor-group.gpu h2');
            if (gpuSection) {
                gpuSection.textContent = hardwareNames.gpu;
            }

            const memorySection = document.querySelector('.sensor-group.ram h2');
            if (memorySection) {
                memorySection.textContent = hardwareNames.memory;
            } const networkSection = document.querySelector('.sensor-group.network h2');
            if (networkSection) {
                networkSection.textContent = hardwareNames.network;
            }

            const storageSection = document.querySelector('.sensor-group.storage h2');
            if (storageSection) {
                storageSection.textContent = hardwareNames.storage;
            }

            headersInitialized = true;
        } let cpuCoresGenerated = false;
        let fansGenerated = false;
        let storageGenerated = false;
        let dynamicSensorMapping = {};
        let fanCardElements = {}; function generateCpuCoreSections(data) {
            if (cpuCoresGenerated) return;

            const cpuCoreLoads = [];
            const cpuCoreTemps = [];
            const cpuCoreClocks = [];

            function extractCpuCoreData(node) {
                if (node.Type === 'Load' && node.Text && node.Text.includes('CPU Core') && node.SensorId) {
                    cpuCoreLoads.push(node);
                } else if (node.Type === 'Temperature' && node.Text && node.Text.includes('CPU Core') &&
                    !node.Text.includes('Distance') && node.SensorId) {
                    cpuCoreTemps.push(node);
                } else if (node.Type === 'Clock' && node.Text && node.Text.includes('CPU Core') && node.SensorId) {
                    cpuCoreClocks.push(node);
                }

                if (node.Children) {
                    node.Children.forEach(child => extractCpuCoreData(child));
                }
            }
            extractCpuCoreData(data); const loadsSection = document.getElementById('cpu-core-loads-section');
            if (loadsSection && cpuCoreLoads.length > 0) {
                const graphContainer = loadsSection.querySelector('.cpu-graph-container');
                cpuCoreLoads.forEach((coreLoad, index) => {
                    const coreBar = createCpuCoreBar(coreLoad, '%');
                    graphContainer.appendChild(coreBar);

                    const htmlId = generateHtmlId(coreLoad.Text, 'load');
                    dynamicSensorMapping[htmlId] = {
                        apiId: coreLoad.SensorId,
                        barApiId: coreLoad.SensorId,
                    };
                });
            }

            const tempsSection = document.getElementById('cpu-core-temps-section');
            if (tempsSection && cpuCoreTemps.length > 0) {
                const graphContainer = tempsSection.querySelector('.cpu-graph-container');
                cpuCoreTemps.forEach((coreTemp, index) => {
                    const coreBar = createCpuCoreBar(coreTemp, '°C');
                    graphContainer.appendChild(coreBar);

                    const htmlId = generateHtmlId(coreTemp.Text, 'temp');
                    dynamicSensorMapping[htmlId] = {
                        apiId: coreTemp.SensorId,
                        type: 'Temperature',
                        barApiId: coreTemp.SensorId,
                    };
                });
            }

            const clocksSection = document.getElementById('cpu-core-clocks-section');
            if (clocksSection && cpuCoreClocks.length > 0) {
                const graphContainer = clocksSection.querySelector('.cpu-graph-container');
                cpuCoreClocks.forEach((coreClock, index) => {
                    const coreBar = createCpuCoreBar(coreClock, 'GHz');
                    graphContainer.appendChild(coreBar);

                    const htmlId = generateHtmlId(coreClock.Text, 'clock');
                    dynamicSensorMapping[htmlId] = {
                        apiId: coreClock.SensorId,
                        type: 'Clock',
                        parseFactor: 1,
                        fixed: 0
                    };
                });
            } cpuCoresGenerated = true;
        }
        function generateFanSections(data) {
            if (fansGenerated) return;

            const fanSensors = [];
            const fanControls = [];

            function extractFanData(node) {
                if (node.Type === 'Fan' && node.SensorId && node.Text) {
                    fanSensors.push(node);
                } else if (node.Type === 'Control' && node.SensorId && node.Text &&
                    (node.Text.toLowerCase().includes('fan') || node.Text.toLowerCase().includes('pump'))) {
                    fanControls.push(node);
                }

                if (node.Children) {
                    node.Children.forEach(child => extractFanData(child));
                }
            }
            extractFanData(data); const fansSection = document.getElementById('fans-section');
            if (fansSection && fanSensors.length > 0) {
                const fanControlMap = {};
                fanControls.forEach(control => {
                    const controlName = control.Text.toLowerCase().replace(/\s+/g, ' ').trim();
                    const matchingFan = fanSensors.find(fan => {
                        const fanName = fan.Text.toLowerCase().replace(/\s+/g, ' ').trim();

                        if (fanName === controlName) return true;

                        const fanNameClean = fanName.replace(/\bfan\b/g, '').trim();
                        const controlNameClean = controlName.replace(/\bfan\b/g, '').trim();

                        if (fanNameClean && controlNameClean &&
                            (fanNameClean.includes(controlNameClean) || controlNameClean.includes(fanNameClean))) {
                            return true;
                        }

                        if (fanName.includes('gpu') && controlName.includes('gpu')) {
                            const fanNumber = fanName.match(/(\d+)/);
                            const controlNumber = controlName.match(/(\d+)/);
                            if (fanNumber && controlNumber && fanNumber[1] === controlNumber[1]) {
                                return true;
                            }
                        }

                        return false;
                    });
                    if (matchingFan) {
                        fanControlMap[matchingFan.SensorId] = control;
                    }
                }); fanSensors.forEach(fanSensor => {
                    const fanCard = createFanCard(fanSensor, fanControlMap[fanSensor.SensorId]);
                    fansSection.appendChild(fanCard);

                    const rpmHtmlId = generateHtmlId(fanSensor.Text, 'rpm');
                    fanCardElements[rpmHtmlId] = fanCard;

                    dynamicSensorMapping[rpmHtmlId] = {
                        apiId: fanSensor.SensorId,
                        type: 'Fan',
                        fixed: 0
                    }; const matchingControl = fanControlMap[fanSensor.SensorId];
                    if (matchingControl) {
                        const controlHtmlId = generateHtmlId(fanSensor.Text, 'control');
                        dynamicSensorMapping[controlHtmlId] = {
                            apiId: matchingControl.SensorId,
                            type: 'Control',
                            barMax: 100
                        };
                    }
                });
            } fansGenerated = true;
        }
        function createFanCard(fanSensor, controlSensor) {
            const rpmHtmlId = generateHtmlId(fanSensor.Text, 'rpm');
            const controlHtmlId = generateHtmlId(fanSensor.Text, 'control');

            const hasControl = controlSensor !== undefined;

            const card = document.createElement('div');
            card.innerHTML = createCard(
                'fas fa-fan',
                fanSensor.Text,
                rpmHtmlId,
                'RPM',
                hasControl ? `${controlHtmlId}-bar` : null
            );

            return card.firstElementChild;
        }
        function generateStorageSections(data) {
            if (storageGenerated) return;

            const storageDevices = [];

            function extractStorageData(node) {
                if (node.Type === 'Storage' && node.Text && node.Children) {
                    storageDevices.push(node);
                }

                if (node.Children) {
                    node.Children.forEach(child => extractStorageData(child));
                }
            }
            extractStorageData(data);

            const storageSection = document.getElementById('dashboard-container');
            if (storageSection && storageDevices.length > 0) {
                storageDevices.forEach(storageDevice => {
                    const storageCard = createStorageDevice(storageDevice);
                    storageSection.appendChild(storageCard);
                });
            }

            storageGenerated = true;
        }
        function createStorageDevice(storageDevice) {
            const deviceName = storageDevice.Text;
            const devicePrefix = storageDevice.Children[0]?.Children[0]?.SensorId?.split('/').slice(0, 3).join('/') || '';

            const sensors = {
                temperatures: [],
                usedSpace: null,
                readActivity: null,
                writeActivity: null,
                totalActivity: null,
                readRate: null,
                writeRate: null,
                dataRead: null,
                dataWritten: null,
                powerOnHours: null
            };

            function parseSensors(node) {
                if (node.Type === 'Temperature' && node.SensorId) {
                    sensors.temperatures.push(node);
                } else if (node.Type === 'Load' && node.SensorId && node.Text) {
                    if (node.Text.includes('Used Space')) {
                        sensors.usedSpace = node;
                    } else if (node.Text.includes('Read Activity')) {
                        sensors.readActivity = node;
                    } else if (node.Text.includes('Write Activity')) {
                        sensors.writeActivity = node;
                    } else if (node.Text.includes('Total Activity')) {
                        sensors.totalActivity = node;
                    }
                } else if (node.Type === 'Throughput' && node.SensorId && node.Text) {
                    if (node.Text.includes('Read Rate')) {
                        sensors.readRate = node;
                    } else if (node.Text.includes('Write Rate')) {
                        sensors.writeRate = node;
                    }
                } else if (node.Type === 'Data' && node.SensorId && node.Text) {
                    if (node.Text.includes('Data Read')) {
                        sensors.dataRead = node;
                    } else if (node.Text.includes('Data Written')) {
                        sensors.dataWritten = node;
                    }
                } else if (node.Type === 'Level' && node.SensorId && node.Text) {
                    if (node.Text.includes('Power On Hours') || node.Text.includes('Power-On Hours')) {
                        sensors.powerOnHours = node;
                    }
                }

                if (node.Children) {
                    node.Children.forEach(child => parseSensors(child));
                }
            }
            parseSensors(storageDevice);

            const sensorCards = [];

            if (sensors.usedSpace) {
                const usedSpaceId = generateHtmlId(deviceName + '-used-space', 'value');

                sensorCards.push(createCard(
                    'fas fa-hdd',
                    'Storage',
                    usedSpaceId,
                    'GB',
                    `${usedSpaceId}-bar`
                ));

                dynamicSensorMapping[usedSpaceId] = {
                    apiId: sensors.usedSpace.SensorId,
                    type: 'Load',
                    formatter: (value) => formatStorageCapacity(value, deviceName),
                    fixed: 1
                };
            } if (sensors.totalActivity) {
                const totalActivityId = generateHtmlId(deviceName + '-total-activity', 'value');

                sensorCards.push(createCard(
                    'fas fa-chart-line',
                    'Utilization',
                    totalActivityId,
                    '%',
                    `${totalActivityId}-bar`
                ));

                dynamicSensorMapping[totalActivityId] = {
                    apiId: sensors.totalActivity.SensorId,
                    type: 'Load',
                    barApiId: sensors.totalActivity.SensorId,
                    fixed: 1
                };
            } if (sensors.readRate) {
                const readRateId = generateHtmlId(deviceName + '-read-rate', 'value');

                sensorCards.push(createCard(
                    'fas fa-download',
                    'Read',
                    readRateId,
                    'MB/s'
                )); dynamicSensorMapping[readRateId] = {
                    apiId: sensors.readRate.SensorId,
                    type: 'Throughput',
                    parseFactor: 1 / 1000000,
                    fixed: 1
                };
            } if (sensors.writeRate) {
                const writeRateId = generateHtmlId(deviceName + '-write-rate', 'value');

                sensorCards.push(createCard(
                    'fas fa-upload',
                    'Write',
                    writeRateId,
                    'MB/s'
                )); dynamicSensorMapping[writeRateId] = {
                    apiId: sensors.writeRate.SensorId,
                    type: 'Throughput',
                    parseFactor: 1 / 1000000,
                    fixed: 1
                };
            } sensors.temperatures.forEach((tempSensor, index) => {
                const tempId = generateHtmlId(deviceName + `-temp-${index}`, 'value');

                sensorCards.push(createCard(
                    'fas fa-thermometer-half',
                    tempSensor.Text,
                    tempId,
                    '°C'
                )); dynamicSensorMapping[tempId] = {
                    apiId: tempSensor.SensorId,
                    type: 'Temperature',
                    fixed: 0
                };
            }); if (sensors.dataRead) {
                const dataReadId = generateHtmlId(deviceName + '-data-read', 'value');

                sensorCards.push(createCard(
                    'fas fa-database',
                    'Total Read',
                    dataReadId,
                    'GB'
                ));

                dynamicSensorMapping[dataReadId] = {
                    apiId: sensors.dataRead.SensorId,
                    type: 'Data',
                    fixed: 0
                };
            } if (sensors.dataWritten) {
                const dataWrittenId = generateHtmlId(deviceName + '-data-written', 'value');

                sensorCards.push(createCard(
                    'fas fa-database',
                    'Total Written',
                    dataWrittenId,
                    'GB'
                ));

                dynamicSensorMapping[dataWrittenId] = {
                    apiId: sensors.dataWritten.SensorId,
                    type: 'Data',
                    fixed: 0
                };
            } if (sensors.powerOnHours) {
                const powerOnHoursId = generateHtmlId(deviceName + '-power-on-hours', 'value');

                sensorCards.push(createCard(
                    'fas fa-clock',
                    'Power On Time',
                    powerOnHoursId,
                    ''
                ));

                dynamicSensorMapping[powerOnHoursId] = {
                    apiId: sensors.powerOnHours.SensorId,
                    type: 'Level',
                    formatter: formatPowerOnHours,
                    fixed: 0
                };
            }


            const card = document.createElement('div');
            card.className = 'glass-pane sensor-group';
            card.innerHTML = `<h2>${deviceName}</h2>
                ${sensorCards.join('')}
                `;

            return card;
        }
        function generateHtmlId(sensorText, type) {
            return sensorText.toLowerCase()
                .replace(/cpu core #(\d+)/g, 'cpu-core$1')
                .replace(/thread #(\d+)/g, 'thread$1')
                .replace(/gpu fan (\d+)/g, 'gpu-fan$1')
                .replace(/system fan #(\d+)/g, 'system-fan$1')
                .replace(/\s+/g, '-')
                .replace(/[^a-z0-9-]/g, '') + '-' + type;
        }
        function createCpuCoreBar(sensor, unit) {
            const htmlId = generateHtmlId(sensor.Text, unit === '%' ? 'load' : (unit === '°C' ? 'temp' : 'clock'));
            const bar = document.createElement('div');
            bar.className = 'cpu-core-bar';
            bar.innerHTML = `
                <div class="cpu-core-bar-fill" id="${htmlId}-bar"></div>
                <span class="cpu-core-bar-value">
                    <span id="${htmlId}">
                </span>
            `;

            return bar;
        }

        function parseValue(valueString) {
            if (!valueString) return NaN;
            const match = valueString.match(/(-?\d+(\.\d+)?)/);
            return match ? parseFloat(match[1]) : NaN;
        }

        function formatVRAM(usedValue) {
            if (isNaN(usedValue)) return '';

            const totalSensor = flatSensorData['/gpu-nvidia/0/smalldata/2'];
            if (totalSensor && totalSensor.Value !== undefined) {
                let totalValue = parseValue(totalSensor.Value);
                if (!isNaN(totalValue)) {
                    return `${(usedValue / 1024).toFixed(1)} / ${(totalValue / 1024).toFixed(0)}`;
                }
            }

            return usedValue.toFixed(1);
        }

        function formatMemory(usedValue) {
            if (isNaN(usedValue)) return '';

            const availableSensor = flatSensorData['/ram/data/1'];
            if (availableSensor && availableSensor.Value !== undefined) {
                let availableValue = parseValue(availableSensor.Value);
                if (!isNaN(availableValue)) {
                    const totalValue = usedValue + availableValue;
                    return `${usedValue.toFixed(1)} / ${totalValue.toFixed(0)}`;
                }
            }

            return usedValue.toFixed(1);
        }

        const sensorMapping = {
            'cpu-total-load': { apiId: '/intelcpu/0/load/0', type: 'Load', barApiId: '/intelcpu/0/load/0' },
            'cpu-max-load': { apiId: '/intelcpu/0/load/1', type: 'Load', barApiId: '/intelcpu/0/load/1' },
            'cpu-package-power': { apiId: '/intelcpu/0/power/0', type: 'Power', fixed: 0 },
            'cpu-cores-power': { apiId: '/intelcpu/0/power/1', type: 'Power', fixed: 0 },
            'cpu-core-voltage': { apiId: '/intelcpu/0/voltage/0', type: 'Voltage', fixed: 3 },

            'cpu-package-temp': { apiId: '/intelcpu/0/temperature/10', type: 'Temperature', barApiId: '/intelcpu/0/temperature/10' },
            'cpu-core-max-temp': { apiId: '/intelcpu/0/temperature/21', type: 'Temperature', barApiId: '/intelcpu/0/temperature/21' },
            'cpu-core-avg-temp': { apiId: '/intelcpu/0/temperature/22', type: 'Temperature', barApiId: '/intelcpu/0/temperature/22' },

            'gpu-core-load': { apiId: '/gpu-nvidia/0/load/0', type: 'Load', barApiId: '/gpu-nvidia/0/load/0' },
            'gpu-vram-used': { apiId: '/gpu-nvidia/0/smalldata/1', type: 'SmallData', parseFactor: 1, fixed: 1, barApiId: '/gpu-nvidia/0/load/3', formatter: formatVRAM },
            'gpu-core-temp': { apiId: '/gpu-nvidia/0/temperature/0', type: 'Temperature', barApiId: '/gpu-nvidia/0/temperature/0' },
            'gpu-hotspot-temp': { apiId: '/gpu-nvidia/0/temperature/2', type: 'Temperature', barApiId: '/gpu-nvidia/0/temperature/2' },
            'gpu-memory-temp': { apiId: '/gpu-nvidia/0/temperature/3', type: 'Temperature', barApiId: '/gpu-nvidia/0/temperature/3' },
            'gpu-power': { apiId: '/gpu-nvidia/0/power/0', type: 'Power', fixed: 0 },
            'gpu-power-utilization': { apiId: '/gpu-nvidia/0/load/4', type: 'Load', barApiId: '/gpu-nvidia/0/load/4' },

            'gpu-pcie-rx': { apiId: '/gpu-nvidia/0/throughput/0', type: 'Throughput', parseFactor: 1 / 1000000, fixed: 0 },
            'gpu-pcie-tx': { apiId: '/gpu-nvidia/0/throughput/1', type: 'Throughput', parseFactor: 1 / 1000000, fixed: 0 },

            'ram': { apiId: '/ram/data/0', type: 'Data', fixed: 1, formatter: formatMemory, barApiId: '/ram/load/0' },
            'virtual-ram': { apiId: '/ram/data/2', type: 'Data', fixed: 1, formatter: formatVirtualMemory, barApiId: '/ram/load/1' },
        };

        let networkInterfaceMappingsInitialized = false;

        function findActiveNetworkInterface(sensorData) {
            const networkInterfaces = [];

            function searchForNetworks(node) {
                if (node.Type === 'Network' && node.Children) {
                    let hasDataSensors = false;
                    let uploadSensor = null;
                    let downloadSensor = null;
                    let throughputUpload = null;
                    let throughputDownload = null;

                    function findDataSensors(subNode) {
                        if (subNode.Children) {
                            subNode.Children.forEach(child => {
                                if (child.Type === 'Data') {
                                    if (child.Text && child.Text.includes('Upload')) {
                                        uploadSensor = child.SensorId;
                                        hasDataSensors = true;
                                    } else if (child.Text && child.Text.includes('Download')) {
                                        downloadSensor = child.SensorId;
                                        hasDataSensors = true;
                                    }
                                } else if (child.Type === 'Throughput') {
                                    if (child.Text && child.Text.includes('Upload')) {
                                        throughputUpload = child.SensorId;
                                    } else if (child.Text && child.Text.includes('Download')) {
                                        throughputDownload = child.SensorId;
                                    }
                                }
                                findDataSensors(child);
                            });
                        }
                    }

                    findDataSensors(node); if (hasDataSensors && uploadSensor && downloadSensor) {
                        const uploadData = flatSensorData[uploadSensor];
                        const downloadData = flatSensorData[downloadSensor];

                        let totalData = 0;
                        if (uploadData && uploadData.Value) {
                            const uploadValue = parseValue(uploadData.Value);
                            if (!isNaN(uploadValue)) totalData += uploadValue;
                        }
                        if (downloadData && downloadData.Value) {
                            const downloadValue = parseValue(downloadData.Value);
                            if (!isNaN(downloadValue)) totalData += downloadValue;
                        }

                        networkInterfaces.push({
                            name: node.Text,
                            totalData: totalData,
                            uploadSensor: uploadSensor,
                            downloadSensor: downloadSensor,
                            throughputUpload: throughputUpload,
                            throughputDownload: throughputDownload
                        });
                    }
                }

                if (node.Children) {
                    node.Children.forEach(child => searchForNetworks(child));
                }
            } searchForNetworks(sensorData);

            networkInterfaces.sort((a, b) => {
                const aIsWifi = a.name.toLowerCase().includes('wi-fi') || a.name.toLowerCase().includes('wifi');
                const bIsWifi = b.name.toLowerCase().includes('wi-fi') || b.name.toLowerCase().includes('wifi');

                if (aIsWifi && !bIsWifi) return -1;
                if (!aIsWifi && bIsWifi) return 1;

                return b.totalData - a.totalData;
            });

            return networkInterfaces.length > 0 ? networkInterfaces[0] : null;
        }

        function initializeNetworkMappings(sensorData) {
            if (networkInterfaceMappingsInitialized) return;

            const activeInterface = findActiveNetworkInterface(sensorData);

            if (activeInterface) {
                sensorMapping['wifi-download'] = {
                    apiId: activeInterface.throughputDownload,
                    type: 'Throughput',
                    parseFactor: 1 / 1000000,
                    fixed: 1
                };
                sensorMapping['wifi-upload'] = {
                    apiId: activeInterface.throughputUpload,
                    type: 'Throughput',
                    parseFactor: 1 / 1000000,
                    fixed: 1
                };
                sensorMapping['wifi-total-download'] = {
                    apiId: activeInterface.downloadSensor,
                    type: 'Data',
                    fixed: 1
                };
                sensorMapping['wifi-total-upload'] = {
                    apiId: activeInterface.uploadSensor,
                    type: 'Data',
                    fixed: 1
                };

                networkInterfaceMappingsInitialized = true;
            } else {
                console.warn('No active network interface found for dynamic mapping');
            }
        }

        const currentAnimatedValues = new Map();
        const targetValues = new Map();
        const animationFrames = new Map(); const currentProgressBarValues = new Map(); function animateValue(element, targetValue, duration = 500, formatter = null, fixed = 0) {
            const elementId = element.id || element.className;
            const startValue = currentAnimatedValues.get(elementId) || 0;

            if (Math.abs(targetValue - startValue) < 0.01) {
                const displayValue = formatter ? formatter(targetValue) : targetValue.toFixed(fixed);
                if (element.textContent !== displayValue) {
                    element.textContent = displayValue;
                }
                currentAnimatedValues.set(elementId, targetValue);
                return;
            } const startTime = performance.now();

            if (animationFrames.has(elementId)) {
                cancelAnimationFrame(animationFrames.get(elementId));
            }

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);

                const easeProgress = 1 - Math.pow(1 - progress, 3);

                const currentValue = startValue + (targetValue - startValue) * easeProgress;
                currentAnimatedValues.set(elementId, currentValue);

                const displayValue = formatter ? formatter(currentValue) : currentValue.toFixed(fixed);

                if (element.textContent !== displayValue) {
                    element.textContent = displayValue;
                }

                if (progress < 1) {
                    const frameId = requestAnimationFrame(animate);
                    animationFrames.set(elementId, frameId);
                } else {
                    animationFrames.delete(elementId);
                }
            }

            const frameId = requestAnimationFrame(animate);
            animationFrames.set(elementId, frameId);
        } function animateProgressBar(element, targetPercentage, smoothingFactor = 0.05) {
            const elementId = element.id || element.className;

            if (!currentProgressBarValues.has(elementId)) {
                currentProgressBarValues.set(elementId, parseFloat(element.style.width) || 0);
            }

            const currentValue = currentProgressBarValues.get(elementId);

            if (Math.abs(targetPercentage - currentValue) < 0.05) {
                const newWidth = `${targetPercentage}%`;
                if (element.style.width !== newWidth) {
                    element.style.width = newWidth;
                }
                currentProgressBarValues.set(elementId, targetPercentage);
                return;
            }

            if (animationFrames.has(elementId)) {
                cancelAnimationFrame(animationFrames.get(elementId));
            }
            function animate() {
                const currentValue = currentProgressBarValues.get(elementId);
                const difference = targetPercentage - currentValue;

                if (Math.abs(difference) < 0.05) {
                    const finalWidth = `${targetPercentage}%`;
                    if (element.style.width !== finalWidth) {
                        element.style.width = finalWidth;
                    }
                    currentProgressBarValues.set(elementId, targetPercentage);
                    animationFrames.delete(elementId);
                    return;
                }

                const newValue = currentValue + smoothingFactor * difference;
                currentProgressBarValues.set(elementId, newValue);

                const newWidth = `${newValue}%`;
                if (element.style.width !== newWidth) {
                    element.style.width = newWidth;
                }

                const frameId = requestAnimationFrame(animate);
                animationFrames.set(elementId, frameId);
            }

            const frameId = requestAnimationFrame(animate);
            animationFrames.set(elementId, frameId);
        }

        function updateSensorUI(htmlId, value, barValue = null, formatter = null, fixed = 0) {
            if (value === undefined || value === null) {
                return;
            }

            const lastValue = targetValues.get(htmlId);
            if (lastValue !== undefined && !isNaN(value) && Math.abs(lastValue - value) < 0.01) {
                return;
            }

            const valueElem = getCachedElement(htmlId);
            const barElem = barValue !== null ? getCachedElement(`${htmlId}-bar`) : null;

            if (!valueElem && !barElem) {
                return;
            }

            targetValues.set(htmlId, value);

            if (valueElem) {
                if (!isNaN(value)) {
                    animateValue(valueElem, value, 400, formatter, fixed);
                } else {
                    const displayValue = formatter ? formatter(value) : '';
                    if (valueElem.textContent !== displayValue) {
                        valueElem.textContent = displayValue;
                    }
                }
            }

            if (barElem && barValue !== null && barValue >= 0 && !isNaN(value)) {
                const percentage = Math.max(0, Math.min(100, barValue));
                animateProgressBar(barElem, percentage);
            } else if (barElem && barValue !== null) {
                animateProgressBar(barElem, 0);
            }
        }

        function filterZeroRpmFans() {
            if (!fansGenerated || Object.keys(fanCardElements).length === 0) {
                return;
            }

            let visibleFanCount = 0;

            for (const rpmHtmlId in fanCardElements) {
                const fanCard = fanCardElements[rpmHtmlId];
                const config = dynamicSensorMapping[rpmHtmlId];

                if (config && config.apiId) {
                    const sensor = flatSensorData[config.apiId]; if (sensor && sensor.Value !== undefined) {
                        const rpmValue = parseValue(sensor.Value);

                        if (!isNaN(rpmValue) && rpmValue > 0) {
                            fanCard.style.display = '';
                            visibleFanCount++;
                        } else {
                            fanCard.style.display = 'none';
                        }
                    } else {
                        fanCard.style.display = '';
                        visibleFanCount++;
                    }
                }
            }

            const fansSection = document.getElementById('fans-section');
            if (fansSection) {
                if (visibleFanCount === 0) {
                    fansSection.style.display = 'none';
                } else {
                    fansSection.style.display = '';
                }
            }
        }
        async function fetchAndRenderSensorData() {
            try {
                const response = await fetch('http://localhost:8085/data.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                } const data = await response.json();

                if (!headersInitialized) {
                    extractHardwareNames(data);
                    updateSectionHeaders();
                } if (!cpuCoresGenerated) {
                    generateCpuCoreSections(data);
                } if (!fansGenerated) {
                    generateFanSections(data);
                }

                if (!storageGenerated) {
                    generateStorageSections(data);
                }

                flattenSensors(data, Object.keys(flatSensorData).length === 0);

                initializeNetworkMappings(data); requestAnimationFrame(() => {
                    const allSensorMappings = { ...sensorMapping, ...dynamicSensorMapping };

                    const updatesNeeded = [];

                    for (const htmlId in allSensorMappings) {
                        const config = allSensorMappings[htmlId];
                        const sensor = flatSensorData[config.apiId];

                        let value = NaN;
                        let barValue = NaN;

                        if (sensor && sensor.Value !== undefined) {
                            value = parseValue(sensor.Value);

                            if (config.parseFactor !== undefined) {
                                value *= config.parseFactor;
                            }

                            const lastValue = targetValues.get(htmlId);
                            if (lastValue !== undefined && !isNaN(value) && Math.abs(lastValue - value) < 0.01) {
                                continue;
                            }

                            if (config.barApiId) {
                                const barSensor = flatSensorData[config.barApiId];
                                if (barSensor && barSensor.Value !== undefined) {
                                    barValue = parseValue(barSensor.Value);
                                    if (config.parseFactor !== undefined) {
                                        barValue *= config.parseFactor;
                                    }
                                }
                            } else if (sensor.Max !== undefined && config.type === 'Clock') {
                                barValue = parseValue(sensor.Max);
                                if (config.parseFactor !== undefined) {
                                    barValue *= config.parseFactor;
                                }
                            } else if (sensor.Max !== undefined) {
                                barValue = parseValue(sensor.Max);
                                if (config.parseFactor !== undefined) {
                                    barValue *= config.parseFactor;
                                }
                            }
                        } updatesNeeded.push({
                            htmlId,
                            value,
                            barValue,
                            formatter: config.formatter,
                            fixed: config.fixed
                        });
                    }

                    updatesNeeded.forEach(update => {
                        updateSensorUI(update.htmlId, update.value, update.barValue, update.formatter, update.fixed);
                    });

                    filterZeroRpmFans();
                });
            } catch (error) {
                console.error("Error fetching or parsing sensor data:", error);
                requestAnimationFrame(() => {
                    const allSensorMappings = { ...sensorMapping, ...dynamicSensorMapping };
                    Object.keys(allSensorMappings).forEach(htmlId => {
                        const config = allSensorMappings[htmlId];
                        if (config.apiId) {
                            updateSensorUI(htmlId, NaN);
                        }
                    });
                });
            }
        }

        function formatUptime(seconds) {
            if (isNaN(seconds)) return '';
            const days = Math.floor(seconds / (3600 * 24));
            seconds %= (3600 * 24);
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            const secondsRemaining = Math.floor(seconds % 60);
            return `${days}d ${hours}h ${minutes}m ${secondsRemaining}s`;
        }

        fetchAndRenderSensorData();

        interval_ms = 200; let updateInterval = setInterval(fetchAndRenderSensorData, interval_ms);

        document.addEventListener('visibilitychange', function () {
            if (document.hidden) {
                clearInterval(updateInterval);
                console.log('Paused - page not visible');
            } else {
                updateInterval = setInterval(fetchAndRenderSensorData, interval_ms);
                console.log('Resumed - page visible');
                fetchAndRenderSensorData();
            }
        });
    </script>
</body>

</html>