<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensors</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --bg-color-dark: #0c0c0c;
            --bg-color-light: #1a1a1a;
            --text-color: #e0e0e0;
            --accent-color-1: #8d44f6;
            --accent-color-2: #44a6f6;
            --accent-color-3: #44f6d7;
            --accent-color-4: #f6e044;
            --accent-color-5: #f6448d;
            --gradient-1: linear-gradient(135deg, var(--accent-color-1), var(--accent-color-2));
            --gradient-2: linear-gradient(135deg, var(--accent-color-3), var(--accent-color-4));
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: rgba(0, 0, 0, 0.3);
            --blur-strength: 10px;
            --border-radius-main: 20px;
            --border-radius-card: 12px;
            --card-padding: 12px;
            --gap: 16px;
            overflow-y: scroll;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: var(--gap);
            color: var(--text-color);
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: black;
            background-image: linear-gradient(135deg, var(--bg-color-light), var(--bg-color-dark));
        }

        .glass-pane {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: var(--border-radius-main);
            backdrop-filter: blur(var(--blur-strength)) saturate(180%);
            -webkit-backdrop-filter: blur(var(--blur-strength)) saturate(180%);
            padding: var(--gap);
            transition: all 0.3s ease-in-out;
            position: relative;
            break-inside: avoid;
            display: inline-block;
            width: 100%;
            min-width: 320px;
            margin-bottom: var(--gap);
            box-sizing: border-box;
        }

        .glass-pane:hover {
            box-shadow: 0 12px 40px 0 var(--glass-shadow);
            transform: translateY(-2px);
        }

        .dashboard-container {
            columns: 350px;
            column-gap: var(--gap);
            column-fill: balance;
            max-width: 1800px;
            width: 100%;
            margin: 0 auto;
            padding: 0;
            box-sizing: border-box;
        }

        .sensor-group {
            display: flex;
            flex-direction: column;
            gap: var(--card-padding);
            padding: 12px;
        }

        .sensor-group h2 {
            font-size: 1.25em;
            margin: 0;
            color: rgba(129, 138, 150, 0.5);
            text-align: center;
        }

        .sensor-card {
            background: rgba(255, 255, 255, 0.04);
            border-radius: var(--border-radius-card);
            padding: var(--card-padding);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .sensor-card:has(.progress-bar) {
            padding-bottom: 0px;
            padding-inline: 0px;
        }

        .sensor-card:has(.progress-bar) .sensor-value-container {
            margin-right: var(--card-padding);
            margin-bottom: calc(var(--card-padding) * 0.5);
        }

        .sensor-card:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .sensor-card .icon-value {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.1em;
            font-weight: 500;
        }

        .sensor-card .sensor-icon {
            font-size: 1.5em;
            width: 30px;
            flex-shrink: 0;
            text-align: center;
            background: var(--gradient-1);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            transition: background 0.3s ease;
        }

        .sensor-card:has(.progress-bar) .sensor-icon {
            margin-left: var(--card-padding);
        }

        .sensor-card .sensor-label {
            font-size: 0.9em;
            color: #b0b0b0;
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .sensor-card .sensor-value-container {
            display: flex;
            align-items: baseline;
            gap: 8px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .sensor-group.cpu .sensor-icon {
            background: linear-gradient(90deg, #f6448d, #f69b44);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .sensor-group.gpu .sensor-icon {
            background: linear-gradient(90deg, #f6e044, #f6b544);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .sensor-group.ram .sensor-icon {
            background: linear-gradient(90deg, #8d44f6, #f644e9);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .sensor-group.network .sensor-icon {
            background: linear-gradient(90deg, #44f6d7, #44f68d);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .sensor-group.fans .sensor-icon {
            background: linear-gradient(90deg, #f644e9, #44f1b5);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .sensor-card .sensor-value {
            font-weight: bold;
            color: var(--text-color);
            font-size: 1.1em;
            transition: all 0.2s ease-out;
        }

        .sensor-card .sensor-unit {
            font-weight: 500;
            color: var(--text-color);
            opacity: 0.7;
            font-size: 0.9em;
        }

        .progress-bar {
            height: 6px;
            background-color: rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-bar-fill {
            height: 100%;
            width: 0%;
            background: var(--gradient-1);
            border-radius: 16px;
        }

        .sensor-group.cpu .progress-bar-fill {
            background: linear-gradient(90deg, #f6448d, #f69b44);
        }

        .sensor-group.gpu .progress-bar-fill {
            background: linear-gradient(90deg, #f6e044, #f6b544);
        }

        .sensor-group.ram .progress-bar-fill {
            background: linear-gradient(90deg, #8d44f6, #f644e9);
        }

        .sensor-group.fans .progress-bar-fill {
            background: linear-gradient(90deg, #f644e9, #44f1b5);
        }

        @media (max-width: 992px) {
            .dashboard-container {
                columns: 300px;
            }

            .sensor-card .icon-value {
                font-size: 1.05em;
                gap: 10px;
            }

            .sensor-card .sensor-label {
                font-size: 0.85em;
            }
        }

        @media (max-width: 1400px) {
            .dashboard-container {
                columns: 320px;
            }
        }

        @media (max-width: 1200px) {
            .dashboard-container {
                columns: 300px;
            }
        }

        @media (max-width: 800px) {
            .dashboard-container {
                columns: 280px;
                width: 95%;
            }

            .glass-pane {
                padding: var(--card-padding);
                min-width: 250px;
            }

            .sensor-card {
                padding: 12px;
            }

            .sensor-card .icon-value {
                font-size: 1em;
                gap: 10px;
            }

            .sensor-card .sensor-icon {
                font-size: 1.3em;
                width: 25px;
            }

            .sensor-card .sensor-label {
                font-size: 0.85em;
            }

            .sensor-card .sensor-value {
                font-size: 1em;
            }

            .sensor-card .sensor-unit {
                font-size: 0.85em;
            }

            .sensor-group h2 {
                font-size: 1.2em;
            }
        }

        @media (min-width: 1600px) {
            .dashboard-container {
                columns: 380px;
                max-width: 1600px;
            }
        }

        .cpu-graph-container {
            display: flex;
            flex-direction: column;
            gap: 6px;
            overflow: hidden;
        }

        .cpu-core-bar {
            display: flex;
            align-items: center;
            height: 12px;
            background: linear-gradient(65deg, rgba(66, 0, 255, 0.04), rgba(255, 1, 1, 0.01));
            border-radius: 16px;
            padding: 4px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(2px);
        }

        .cpu-core-bar-fill {
            height: 100%;
            position: relative;
            border-radius: 16px;
        }

        /* Load graph gradient - Using UI colors (Pink to Orange like CPU theme) */
        .loads-graph .cpu-core-bar-fill {
            background: linear-gradient(90deg,
                    rgba(68, 166, 246, 0.9) 0%,
                    rgba(68, 246, 215, 0.9) 100%);
            box-shadow: 0 0 8px rgba(246, 68, 141, 0.3);
        }

        /* Temperature graph gradient - Using UI colors (Blue to Cyan like GPU theme) */
        .temps-graph .cpu-core-bar-fill {
            background: linear-gradient(90deg,
                    rgba(246, 68, 141, 0.9) 0%,
                    rgba(246, 155, 68, 0.9) 100%);
            box-shadow: 0 0 8px rgba(68, 166, 246, 0.3);
        }

        /* Clock graph gradient - Using UI colors (Purple to Pink like RAM theme) */
        .clocks-graph .cpu-core-bar-fill {
            background: linear-gradient(90deg,
                    rgba(255, 75, 174, 0.8) 0%,
                    rgba(94, 182, 255, 0.9) 100%);
            box-shadow: 0 0 8px rgba(141, 68, 246, 0.3);
        }

        .cpu-core-bar-value {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-55%);
            font-size: 0.8em;
            font-weight: 700;
            color: transparent;
            text-shadow: 0px 0px 2px #000;
            opacity: 0.4;
            color: #aab;
            z-index: 2;
            white-space: nowrap;
        }

        /* Hover effects */
        .cpu-core-bar:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .loads-graph .cpu-core-bar:hover .cpu-core-bar-fill {
            box-shadow: 0 0 12px rgba(246, 68, 141, 0.5);
        }

        .temps-graph .cpu-core-bar:hover .cpu-core-bar-fill {
            box-shadow: 0 0 12px rgba(68, 166, 246, 0.5);
        }

        .clocks-graph .cpu-core-bar:hover .cpu-core-bar-fill {
            box-shadow: 0 0 12px rgba(141, 68, 246, 0.5);
        }
    </style>
</head>

<body>
    <div class="dashboard-container">

        <!-- CPU Load & Performance -->
        <div class="glass-pane sensor-group cpu">
            <h2 id="cpu">CPU</h2>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-microchip sensor-icon"></i>
                    <span class="sensor-label">Total</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-total-load"></span><span class="sensor-unit">%</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="cpu-total-load-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-tachometer-alt sensor-icon"></i>
                    <span class="sensor-label">Core Max Load</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-max-load"></span><span class="sensor-unit">%</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="cpu-max-load-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-bolt sensor-icon"></i>
                    <span class="sensor-label">Package Power</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-package-power"></span><span class="sensor-unit">W</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-bolt sensor-icon"></i>
                    <span class="sensor-label">Cores Power</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-cores-power"></span><span class="sensor-unit">W</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-bolt sensor-icon"></i>
                    <span class="sensor-label">CPU Core</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-core-voltage"></span><span class="sensor-unit">V</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- CPU Temperatures -->
        <div class="glass-pane sensor-group cpu">
            <h2>CPU Temps</h2>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-thermometer-half sensor-icon"></i>
                    <span class="sensor-label">Package</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-package-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="cpu-package-temp-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-thermometer-full sensor-icon"></i>
                    <span class="sensor-label">Core Max</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-core-max-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="cpu-core-max-temp-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-thermometer-quarter sensor-icon"></i>
                    <span class="sensor-label">Core Avg</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="cpu-core-avg-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="cpu-core-avg-temp-bar"></div>
                </div>
            </div>
            <div class="" id="cpu-core-temps-section">
                <div class="cpu-graph-container temps-graph">
                    <!-- Core temperature graph bars will be dynamically generated here -->
                </div>
            </div>
        </div>

        <!-- Voltage -->
        <div class="glass-pane sensor-group cpu" id="cpu-core-loads-section">
            <h2>Core Load</h2>
            <div class="cpu-graph-container loads-graph">
                <!-- Core load graph bars will be dynamically generated here -->
            </div>
        </div>

        <!-- CPU Core Clocks - Graph Style -->
        <div class="glass-pane sensor-group cpu" id="cpu-core-clocks-section">
            <h2>Core Clock</h2>
            <div class="cpu-graph-container clocks-graph">
                <!-- Core clock graph bars will be dynamically generated here -->
            </div>
        </div>

        <!-- GPU Sensors -->
        <div class="glass-pane sensor-group gpu">
            <h2>GPU</h2>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-gamepad sensor-icon"></i>
                    <span class="sensor-label">Core Load</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-core-load"></span><span class="sensor-unit">%</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="gpu-core-load-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-hdd sensor-icon"></i>
                    <span class="sensor-label">VRAM Used</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-vram-used"></span><span class="sensor-unit">GB</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="gpu-vram-used-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-thermometer-half sensor-icon"></i>
                    <span class="sensor-label">Core Temp</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-core-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="gpu-core-temp-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-fire sensor-icon"></i>
                    <span class="sensor-label">Hot Spot</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-hotspot-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="gpu-hotspot-temp-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-microchip sensor-icon"></i>
                    <span class="sensor-label">Mem Temp</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-memory-temp"></span><span class="sensor-unit">°C</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="gpu-memory-temp-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-bolt sensor-icon"></i>
                    <span class="sensor-label">Power</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-power"></span><span class="sensor-unit">W</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-ethernet sensor-icon"></i>
                    <span class="sensor-label">PCIe Rx</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-pcie-rx"></span><span class="sensor-unit">MB/s</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-ethernet sensor-icon"></i>
                    <span class="sensor-label">PCIe Tx</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="gpu-pcie-tx"></span><span class="sensor-unit">MB/s</span>
                    </div>
                </div>
            </div>
        </div> <!-- Memory -->
        <div class="glass-pane sensor-group ram">
            <h2>Memory</h2>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-memory sensor-icon"></i>
                    <span class="sensor-label">Physical</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="memory-combined"></span><span class="sensor-unit">GB</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="memory-combined-bar"></div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-database sensor-icon"></i>
                    <span class="sensor-label">Virtual</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="virtual-memory-combined"></span><span
                            class="sensor-unit">GB</span>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-bar-fill" id="virtual-memory-combined-bar"></div>
                </div>
            </div>
        </div><!-- Fans -->
        <div class="glass-pane sensor-group fans" id="fans-section">
            <h2>Fans</h2>
            <!-- Fan cards will be dynamically generated here -->
        </div>

        <!-- Network -->
        <div class="glass-pane sensor-group network">
            <h2>Network</h2>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-wifi sensor-icon"></i>
                    <span class="sensor-label">Down</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="wifi-download"></span><span class="sensor-unit">MB/s</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-wifi sensor-icon"></i>
                    <span class="sensor-label">Up</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="wifi-upload"></span><span class="sensor-unit">MB/s</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-download sensor-icon"></i>
                    <span class="sensor-label">Total Down</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="wifi-total-download"></span><span class="sensor-unit">GB</span>
                    </div>
                </div>
            </div>
            <div class="sensor-card">
                <div class="icon-value">
                    <i class="fas fa-upload sensor-icon"></i>
                    <span class="sensor-label">Total Up</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="wifi-total-upload"></span><span class="sensor-unit">GB</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Global map to store flattened sensor data by SensorId for quick lookup
        const flatSensorData = {};

        // Cache DOM elements to avoid repeated queries
        const domElementCache = new Map();

        // Flag to track if headers have been initialized
        let headersInitialized = false;

        // Global storage for hardware names
        const hardwareNames = {
            cpu: 'CPU',
            gpu: 'GPU',
            memory: 'Memory',
            network: 'Network'
        };        // Function to get cached DOM element
        function getCachedElement(id) {
            if (!domElementCache.has(id)) {
                domElementCache.set(id, document.getElementById(id));
            }
            return domElementCache.get(id);
        }

        // Function to recursively flatten the nested JSON structure
        function flattenSensors(node, clearFirst = false) {
            if (clearFirst) {
                // Only clear when explicitly requested (first time or structure change)
                for (const key in flatSensorData) {
                    delete flatSensorData[key];
                }
            }

            if (node.SensorId) {
                flatSensorData[node.SensorId] = node;
            }
            if (node.Children) {
                node.Children.forEach(child => flattenSensors(child, false));
            }
        }

        // Function to extract hardware names from the API response
        function extractHardwareNames(data) {
            function findHardwareByType(node) {
                if (node.Type) {
                    // Check for CPU
                    if (node.Type === 'Cpu' && node.Text) {
                        hardwareNames.cpu = node.Text.replace(/Intel|AMD|Core|Ryzen|Processor/ig, '').trim();
                    }
                    // Check for GPU  
                    else if ((node.Type === 'GpuNvidia' || node.Type === 'GpuAmd' || node.Type === 'Gpu') && node.Text) {
                        hardwareNames.gpu = node.Text.replace(/NVIDIA|GeForce|AMD|Radeon/ig, '').trim();
                    }
                    // Check for Memory
                    else if (node.Type === 'Memory' && node.Text) {
                        hardwareNames.memory = node.Text.replace(/Generic Memory/ig, 'Memory').trim();
                    }
                    // Check for Network
                    else if (node.Type === 'Network' && node.Text) {
                        hardwareNames.network = node.Text;
                    }
                }

                if (node.Children) {
                    node.Children.forEach(child => findHardwareByType(child));
                }
            }

            findHardwareByType(data);
        }        // Function to update section headers with hardware names (only run once)
        function updateSectionHeaders() {
            if (headersInitialized) return; // Skip if already initialized

            // Cache header elements for reuse
            const cpu = document.getElementById('cpu');
            cpu.textContent = hardwareNames.cpu;

            // Update other sections
            const gpuSection = document.querySelector('.sensor-group.gpu h2');
            if (gpuSection) {
                gpuSection.textContent = hardwareNames.gpu;
            }

            const memorySection = document.querySelector('.sensor-group.ram h2');
            if (memorySection) {
                memorySection.textContent = hardwareNames.memory;
            }

            const networkSection = document.querySelector('.sensor-group.network h2');
            if (networkSection) {
                networkSection.textContent = hardwareNames.network;
            }

            headersInitialized = true;
        }        // Dynamic CPU core sections generation
        let cpuCoresGenerated = false;
        let fansGenerated = false;
        let dynamicSensorMapping = {}; // Store dynamically generated sensor mappings
        let fanCardElements = {}; // Store references to fan card DOM elements for visibility control

        // Function to generate CPU core sensor cards dynamically
        function generateCpuCoreSections(data) {
            if (cpuCoresGenerated) return; // Only generate once

            // Find CPU core data from the API response
            const cpuCoreLoads = [];
            const cpuCoreTemps = [];
            const cpuCoreClocks = [];

            function extractCpuCoreData(node) {
                if (node.Type === 'Load' && node.Text && node.Text.includes('CPU Core') && node.SensorId) {
                    cpuCoreLoads.push(node);
                } else if (node.Type === 'Temperature' && node.Text && node.Text.includes('CPU Core') &&
                    !node.Text.includes('Distance') && node.SensorId) {
                    cpuCoreTemps.push(node);
                } else if (node.Type === 'Clock' && node.Text && node.Text.includes('CPU Core') && node.SensorId) {
                    cpuCoreClocks.push(node);
                }

                if (node.Children) {
                    node.Children.forEach(child => extractCpuCoreData(child));
                }
            }
            extractCpuCoreData(data);

            // Generate CPU Core Loads section
            const loadsSection = document.getElementById('cpu-core-loads-section');
            if (loadsSection && cpuCoreLoads.length > 0) {
                const graphContainer = loadsSection.querySelector('.cpu-graph-container');
                cpuCoreLoads.forEach((coreLoad, index) => {
                    const coreBar = createCpuCoreBar(coreLoad, '%');
                    graphContainer.appendChild(coreBar);

                    // Add to dynamic sensor mapping
                    const htmlId = generateHtmlId(coreLoad.Text, 'load');
                    dynamicSensorMapping[htmlId] = {
                        apiId: coreLoad.SensorId,
                        type: 'Load',
                        barMax: 100
                    };
                });
            }

            // Generate CPU Core Temperatures section
            const tempsSection = document.getElementById('cpu-core-temps-section');
            if (tempsSection && cpuCoreTemps.length > 0) {
                const graphContainer = tempsSection.querySelector('.cpu-graph-container');
                cpuCoreTemps.forEach((coreTemp, index) => {
                    const coreBar = createCpuCoreBar(coreTemp, '°C');
                    graphContainer.appendChild(coreBar);

                    // Add to dynamic sensor mapping
                    const htmlId = generateHtmlId(coreTemp.Text, 'temp');
                    dynamicSensorMapping[htmlId] = {
                        apiId: coreTemp.SensorId,
                        type: 'Temperature',
                        barMax: 100
                    };
                });
            }

            // Generate CPU Core Clocks section
            const clocksSection = document.getElementById('cpu-core-clocks-section');
            if (clocksSection && cpuCoreClocks.length > 0) {
                const graphContainer = clocksSection.querySelector('.cpu-graph-container');
                cpuCoreClocks.forEach((coreClock, index) => {
                    const coreBar = createCpuCoreBar(coreClock, 'GHz');
                    graphContainer.appendChild(coreBar);

                    // Add to dynamic sensor mapping
                    const htmlId = generateHtmlId(coreClock.Text, 'clock');
                    dynamicSensorMapping[htmlId] = {
                        apiId: coreClock.SensorId,
                        type: 'Clock',
                        parseFactor: 1,
                        fixed: 0
                    };
                });
            } cpuCoresGenerated = true;
        }        // Function to generate fan sections dynamically from API data
        function generateFanSections(data) {
            if (fansGenerated) return; // Only generate once

            const fanSensors = [];
            const fanControls = [];

            // Extract all fan sensors and controls from the API response
            function extractFanData(node) {
                if (node.Type === 'Fan' && node.SensorId && node.Text) {
                    fanSensors.push(node);
                } else if (node.Type === 'Control' && node.SensorId && node.Text &&
                    (node.Text.toLowerCase().includes('fan') || node.Text.toLowerCase().includes('pump'))) {
                    fanControls.push(node);
                }

                if (node.Children) {
                    node.Children.forEach(child => extractFanData(child));
                }
            }
            extractFanData(data);

            const fansSection = document.getElementById('fans-section');
            if (fansSection && fanSensors.length > 0) {
                // Create a map to match fan sensors with their controls
                const fanControlMap = {};
                fanControls.forEach(control => {
                    // Try to match fan controls with fan sensors by name
                    const controlName = control.Text.toLowerCase().replace(/\s+/g, ' ').trim();
                    const matchingFan = fanSensors.find(fan => {
                        const fanName = fan.Text.toLowerCase().replace(/\s+/g, ' ').trim();

                        // Direct name match
                        if (fanName === controlName) return true;

                        // Check if control name contains fan name (without "fan" word)
                        const fanNameClean = fanName.replace(/\bfan\b/g, '').trim();
                        const controlNameClean = controlName.replace(/\bfan\b/g, '').trim();

                        if (fanNameClean && controlNameClean &&
                            (fanNameClean.includes(controlNameClean) || controlNameClean.includes(fanNameClean))) {
                            return true;
                        }

                        // Check for GPU fan specific matching
                        if (fanName.includes('gpu') && controlName.includes('gpu')) {
                            const fanNumber = fanName.match(/(\d+)/);
                            const controlNumber = controlName.match(/(\d+)/);
                            if (fanNumber && controlNumber && fanNumber[1] === controlNumber[1]) {
                                return true;
                            }
                        }

                        return false;
                    });
                    if (matchingFan) {
                        fanControlMap[matchingFan.SensorId] = control;
                    }
                });                // Generate fan cards for each fan sensor
                fanSensors.forEach(fanSensor => {
                    const fanCard = createFanCard(fanSensor, fanControlMap[fanSensor.SensorId]);
                    fansSection.appendChild(fanCard);

                    // Store reference to the fan card for visibility control
                    const rpmHtmlId = generateHtmlId(fanSensor.Text, 'rpm');
                    fanCardElements[rpmHtmlId] = fanCard;

                    // Add to dynamic sensor mapping for RPM values
                    dynamicSensorMapping[rpmHtmlId] = {
                        apiId: fanSensor.SensorId,
                        type: 'Fan',
                        fixed: 0
                    };// Add control mapping if available
                    const matchingControl = fanControlMap[fanSensor.SensorId];
                    if (matchingControl) {
                        const controlHtmlId = generateHtmlId(fanSensor.Text, 'control');
                        dynamicSensorMapping[controlHtmlId] = {
                            apiId: matchingControl.SensorId,
                            type: 'Control',
                            barMax: 100
                        };
                    }
                });
            }

            fansGenerated = true;
        }

        // Function to create a fan sensor card element
        function createFanCard(fanSensor, controlSensor) {
            const rpmHtmlId = generateHtmlId(fanSensor.Text, 'rpm');
            const controlHtmlId = generateHtmlId(fanSensor.Text, 'control');

            const card = document.createElement('div');
            card.className = 'sensor-card';

            const hasControl = controlSensor !== undefined;

            card.innerHTML = `
                <div class="icon-value">
                    <i class="fas fa-fan sensor-icon"></i>
                    <span class="sensor-label">${fanSensor.Text}</span>
                    <div class="sensor-value-container">
                        <span class="sensor-value" id="${rpmHtmlId}"></span><span class="sensor-unit">RPM</span>
                    </div>
                </div>
                ${hasControl ? `<div class="progress-bar">
                    <div class="progress-bar-fill" id="${controlHtmlId}-bar"></div>
                </div>` : ''}
            `;

            return card;
        }        // Function to generate HTML ID from sensor text
        function generateHtmlId(sensorText, type) {
            return sensorText.toLowerCase()
                .replace(/cpu core #(\d+)/g, 'cpu-core$1')
                .replace(/thread #(\d+)/g, 'thread$1')
                .replace(/gpu fan (\d+)/g, 'gpu-fan$1')
                .replace(/system fan #(\d+)/g, 'system-fan$1')
                .replace(/\s+/g, '-')
                .replace(/[^a-z0-9-]/g, '') + '-' + type;
        }// Function to create a CPU core graph bar element
        function createCpuCoreBar(sensor, unit) {
            const htmlId = generateHtmlId(sensor.Text, unit === '%' ? 'load' : (unit === '°C' ? 'temp' : 'clock'));
            const bar = document.createElement('div');
            bar.className = 'cpu-core-bar';
            bar.innerHTML = `
                <div class="cpu-core-bar-fill" id="${htmlId}-bar"></div>
                <span class="cpu-core-bar-value">
                    <span id="${htmlId}">
                </span>
            `;

            return bar;
        }
        // Helper to parse numeric value from sensor value string (e.g., "45.5 °C" -> 45.5)
        function parseValue(valueString) {
            if (!valueString) return NaN;
            // Regex to find numbers (integers or floats) at the beginning of the string
            const match = valueString.match(/(-?\d+(\.\d+)?)/);
            return match ? parseFloat(match[1]) : NaN;
        }        // Custom formatter for VRAM display with used/total format
        function formatVRAM(usedValue) {
            if (isNaN(usedValue)) return '';

            // Get total VRAM from the barApiId sensor
            const totalSensor = flatSensorData['/gpu-nvidia/0/smalldata/2'];
            if (totalSensor && totalSensor.Value !== undefined) {
                let totalValue = parseValue(totalSensor.Value);
                if (!isNaN(totalValue)) {
                    // Convert from MB to GB (same factor as used value)
                    totalValue /= 1024;
                    return `${usedValue.toFixed(1)} / ${totalValue.toFixed(0)}`;
                }
            }

            // Fallback to just showing used value if total is not available yet
            return usedValue.toFixed(1);
        }

        // Custom formatter for memory display with used/total format
        function formatMemory(usedValue) {
            if (isNaN(usedValue)) return '';

            // Get available memory from the sensor
            const availableSensor = flatSensorData['/ram/data/1'];
            if (availableSensor && availableSensor.Value !== undefined) {
                let availableValue = parseValue(availableSensor.Value);
                if (!isNaN(availableValue)) {
                    const totalValue = usedValue + availableValue;
                    return `${usedValue.toFixed(1)} / ${totalValue.toFixed(0)}`;
                }
            }

            // Fallback to just showing used value if available is not available yet
            return usedValue.toFixed(1);
        }

        // Custom formatter for virtual memory display with used/total format
        function formatVirtualMemory(usedValue) {
            if (isNaN(usedValue)) return '';

            // Get available virtual memory from the sensor
            const availableSensor = flatSensorData['/ram/data/3'];
            if (availableSensor && availableSensor.Value !== undefined) {
                let availableValue = parseValue(availableSensor.Value);
                if (!isNaN(availableValue)) {
                    const totalValue = usedValue + availableValue;
                    return `${usedValue.toFixed(1)} / ${totalValue.toFixed(0)}`;
                }
            }

            // Fallback to just showing used value if available is not available yet
            return usedValue.toFixed(1);
        }// Mapping of HTML element IDs to API SensorIds and their properties
        // This is crucial for linking the UI to the specific data points in your API
        const sensorMapping = {
            // CPU Performance
            'cpu-total-load': { apiId: '/intelcpu/0/load/0', type: 'Load', barMax: 100 },
            'cpu-max-load': { apiId: '/intelcpu/0/load/1', type: 'Load', barMax: 100 },
            'cpu-package-power': { apiId: '/intelcpu/0/power/0', type: 'Power', fixed: 0 },
            'cpu-cores-power': { apiId: '/intelcpu/0/power/1', type: 'Power', fixed: 0 },
            'cpu-core-voltage': { apiId: '/intelcpu/0/voltage/0', type: 'Voltage', fixed: 3 },

            // CPU Temperatures
            'cpu-package-temp': { apiId: '/intelcpu/0/temperature/10', type: 'Temperature', barMax: 100 },
            'cpu-core-max-temp': { apiId: '/intelcpu/0/temperature/21', type: 'Temperature', barMax: 100 },
            'cpu-core-avg-temp': { apiId: '/intelcpu/0/temperature/22', type: 'Temperature', barMax: 100 },
            'gpu-core-load': { apiId: '/gpu-nvidia/0/load/0', type: 'Load', barMax: 100 },
            'gpu-vram-used': { apiId: '/gpu-nvidia/0/smalldata/1', type: 'SmallData', parseFactor: 1 / 1024, fixed: 1, barApiId: '/gpu-nvidia/0/smalldata/2', formatter: formatVRAM },
            'gpu-core-temp': { apiId: '/gpu-nvidia/0/temperature/0', type: 'Temperature', barMax: 100 },
            'gpu-hotspot-temp': { apiId: '/gpu-nvidia/0/temperature/2', type: 'Temperature', barMax: 100 },
            'gpu-memory-temp': { apiId: '/gpu-nvidia/0/temperature/3', type: 'Temperature', barMax: 100 },
            'gpu-power': { apiId: '/gpu-nvidia/0/power/0', type: 'Power', fixed: 0 },            // Memory
            'memory-combined': { apiId: '/ram/data/0', type: 'Data', fixed: 1, formatter: formatMemory, barApiId: '/ram/load/0', barMax: 100 },
            'virtual-memory-combined': { apiId: '/ram/data/2', type: 'Data', fixed: 1, formatter: formatVirtualMemory, barApiId: '/ram/load/1', barMax: 100 },// Network (Dynamic - will be set automatically)
            'gpu-pcie-rx': { apiId: '/gpu-nvidia/0/throughput/0', type: 'Throughput', parseFactor: 1 / 1000000, fixed: 0 },
            'gpu-pcie-tx': { apiId: '/gpu-nvidia/0/throughput/1', type: 'Throughput', parseFactor: 1 / 1000000, fixed: 0 },
        };

        // Dynamic network interface detection
        let networkInterfaceMappingsInitialized = false;

        // Function to find the active network interface
        function findActiveNetworkInterface(sensorData) {
            const networkInterfaces = [];

            // Recursively search for network interfaces
            function searchForNetworks(node) {
                if (node.Type === 'Network' && node.Children) {
                    // Look for data upload/download sensors to determine if this interface has traffic
                    let hasDataSensors = false;
                    let uploadSensor = null;
                    let downloadSensor = null;
                    let throughputUpload = null;
                    let throughputDownload = null;

                    function findDataSensors(subNode) {
                        if (subNode.Children) {
                            subNode.Children.forEach(child => {
                                if (child.Type === 'Data') {
                                    if (child.Text && child.Text.includes('Upload')) {
                                        uploadSensor = child.SensorId;
                                        hasDataSensors = true;
                                    } else if (child.Text && child.Text.includes('Download')) {
                                        downloadSensor = child.SensorId;
                                        hasDataSensors = true;
                                    }
                                } else if (child.Type === 'Throughput') {
                                    if (child.Text && child.Text.includes('Upload')) {
                                        throughputUpload = child.SensorId;
                                    } else if (child.Text && child.Text.includes('Download')) {
                                        throughputDownload = child.SensorId;
                                    }
                                }
                                findDataSensors(child);
                            });
                        }
                    }

                    findDataSensors(node);

                    if (hasDataSensors && uploadSensor && downloadSensor) {
                        // Get data values to determine which interface is most active
                        const uploadData = flatSensorData[uploadSensor];
                        const downloadData = flatSensorData[downloadSensor];

                        let totalData = 0;
                        if (uploadData && uploadData.Value) {
                            const uploadValue = parseValue(uploadData.Value);
                            if (!isNaN(uploadValue)) totalData += uploadValue;
                        }
                        if (downloadData && downloadData.Value) {
                            const downloadValue = parseValue(downloadData.Value);
                            if (!isNaN(downloadValue)) totalData += downloadValue;
                        }

                        networkInterfaces.push({
                            name: node.Text,
                            totalData: totalData,
                            uploadSensor: uploadSensor,
                            downloadSensor: downloadSensor,
                            throughputUpload: throughputUpload,
                            throughputDownload: throughputDownload
                        });
                    }
                }

                if (node.Children) {
                    node.Children.forEach(child => searchForNetworks(child));
                }
            }

            searchForNetworks(sensorData);

            // Sort by total data and return the most active interface
            // Also prioritize Wi-Fi interfaces over others
            networkInterfaces.sort((a, b) => {
                // Prioritize Wi-Fi interfaces
                const aIsWifi = a.name.toLowerCase().includes('wi-fi') || a.name.toLowerCase().includes('wifi');
                const bIsWifi = b.name.toLowerCase().includes('wi-fi') || b.name.toLowerCase().includes('wifi');

                if (aIsWifi && !bIsWifi) return -1;
                if (!aIsWifi && bIsWifi) return 1;

                // Then sort by data amount
                return b.totalData - a.totalData;
            });

            return networkInterfaces.length > 0 ? networkInterfaces[0] : null;
        }

        // Function to initialize network interface mappings
        function initializeNetworkMappings(sensorData) {
            if (networkInterfaceMappingsInitialized) return;

            const activeInterface = findActiveNetworkInterface(sensorData);

            if (activeInterface) {
                // Add dynamic network mappings to the sensor mapping
                sensorMapping['wifi-download'] = {
                    apiId: activeInterface.throughputDownload,
                    type: 'Throughput',
                    parseFactor: 1 / 1000000,
                    fixed: 1
                };
                sensorMapping['wifi-upload'] = {
                    apiId: activeInterface.throughputUpload,
                    type: 'Throughput',
                    parseFactor: 1 / 1000000,
                    fixed: 1
                };
                sensorMapping['wifi-total-download'] = {
                    apiId: activeInterface.downloadSensor,
                    type: 'Data',
                    fixed: 1
                };
                sensorMapping['wifi-total-upload'] = {
                    apiId: activeInterface.uploadSensor,
                    type: 'Data',
                    fixed: 1
                };

                networkInterfaceMappingsInitialized = true;
            } else {
                console.warn('No active network interface found for dynamic mapping');
            }
        }
        const currentAnimatedValues = new Map();
        const targetValues = new Map();
        const animationFrames = new Map();
        const currentProgressBarValues = new Map();        // Smooth animation function for numeric values
        function animateValue(element, targetValue, duration = 500, formatter = null, fixed = 0) {
            const elementId = element.id || element.className;
            const startValue = currentAnimatedValues.get(elementId) || 0;

            // Skip animation if target value is very close to current value
            if (Math.abs(targetValue - startValue) < 0.01) {
                const displayValue = formatter ? formatter(targetValue) : targetValue.toFixed(fixed);
                if (element.textContent !== displayValue) {
                    element.textContent = displayValue;
                }
                currentAnimatedValues.set(elementId, targetValue);
                return;
            }

            const startTime = performance.now();

            // Cancel any existing animation for this element
            if (animationFrames.has(elementId)) {
                cancelAnimationFrame(animationFrames.get(elementId));
            }

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Use easeOutCubic for smooth deceleration
                const easeProgress = 1 - Math.pow(1 - progress, 3);

                const currentValue = startValue + (targetValue - startValue) * easeProgress;
                currentAnimatedValues.set(elementId, currentValue);

                const displayValue = formatter ? formatter(currentValue) : currentValue.toFixed(fixed);

                // Only update DOM if the display value has actually changed
                if (element.textContent !== displayValue) {
                    element.textContent = displayValue;
                }

                if (progress < 1) {
                    const frameId = requestAnimationFrame(animate);
                    animationFrames.set(elementId, frameId);
                } else {
                    animationFrames.delete(elementId);
                }
            }

            const frameId = requestAnimationFrame(animate);
            animationFrames.set(elementId, frameId);
        }        // Smooth animation function for progress bars using exponential smoothing
        function animateProgressBar(element, targetPercentage, smoothingFactor = 0.05) {
            const elementId = element.id || element.className;

            // Initialize current value if not exists
            if (!currentProgressBarValues.has(elementId)) {
                currentProgressBarValues.set(elementId, parseFloat(element.style.width) || 0);
            }

            const currentValue = currentProgressBarValues.get(elementId);

            // Skip animation if target is very close to current value
            if (Math.abs(targetPercentage - currentValue) < 0.05) {
                const newWidth = `${targetPercentage}%`;
                if (element.style.width !== newWidth) {
                    element.style.width = newWidth;
                }
                currentProgressBarValues.set(elementId, targetPercentage);
                return;
            }

            // Cancel any existing animation for this element
            if (animationFrames.has(elementId)) {
                cancelAnimationFrame(animationFrames.get(elementId));
            }

            function animate() {
                const currentValue = currentProgressBarValues.get(elementId);
                const difference = targetPercentage - currentValue;

                // Check if we're close enough to the target to stop animating
                if (Math.abs(difference) < 0.05) {
                    const finalWidth = `${targetPercentage}%`;
                    if (element.style.width !== finalWidth) {
                        element.style.width = finalWidth;
                    }
                    currentProgressBarValues.set(elementId, targetPercentage);
                    animationFrames.delete(elementId);
                    return;
                }

                // Exponential smoothing: new_value = current + smoothing_factor * (target - current)
                const newValue = currentValue + smoothingFactor * difference;
                currentProgressBarValues.set(elementId, newValue);

                const newWidth = `${newValue}%`;
                if (element.style.width !== newWidth) {
                    element.style.width = newWidth;
                }

                // Continue animation
                const frameId = requestAnimationFrame(animate);
                animationFrames.set(elementId, frameId);
            }

            const frameId = requestAnimationFrame(animate);
            animationFrames.set(elementId, frameId);
        }// Function to update a single sensor's UI elements with smooth animations
        function updateSensorUI(htmlId, value, barMax = null, formatter = null, fixed = 0) {
            // Early exit for invalid values
            if (value === undefined || value === null) {
                return;
            }

            // Skip update if value hasn't changed significantly (for performance)
            const lastValue = targetValues.get(htmlId);
            if (lastValue !== undefined && !isNaN(value) && Math.abs(lastValue - value) < 0.01) {
                return;
            }

            // Cache elements once per update cycle
            const valueElem = getCachedElement(htmlId);
            const barElem = barMax !== null ? getCachedElement(`${htmlId}-bar`) : null;

            // Early exit if no elements exist
            if (!valueElem && !barElem) {
                return;
            }

            targetValues.set(htmlId, value);

            // Handle value element update
            if (valueElem) {
                if (!isNaN(value)) {
                    animateValue(valueElem, value, 400, formatter, fixed);
                } else {
                    // For non-numeric values, update immediately without animation
                    const displayValue = formatter ? formatter(value) : '';
                    if (valueElem.textContent !== displayValue) {
                        valueElem.textContent = displayValue;
                    }
                }
            }

            // Handle progress bar update (only if barMax is provided and valid)
            if (barElem && barMax !== null && barMax > 0 && !isNaN(value)) {
                const percentage = Math.max(0, Math.min(100, (value / barMax) * 100));
                animateProgressBar(barElem, percentage);
            } else if (barElem && barMax !== null) {
                animateProgressBar(barElem, 0);
            }
        }

        // Function to filter out fans with 0 RPM from the visualization
        function filterZeroRpmFans() {
            if (!fansGenerated || Object.keys(fanCardElements).length === 0) {
                return; // No fans generated yet
            }

            let visibleFanCount = 0;

            // Check each fan's RPM value and show/hide accordingly
            for (const rpmHtmlId in fanCardElements) {
                const fanCard = fanCardElements[rpmHtmlId];
                const config = dynamicSensorMapping[rpmHtmlId];

                if (config && config.apiId) {
                    const sensor = flatSensorData[config.apiId];

                    if (sensor && sensor.Value !== undefined) {
                        const rpmValue = parseValue(sensor.Value);

                        if (!isNaN(rpmValue) && rpmValue > 0) {
                            // Fan is spinning, show the card
                            fanCard.style.display = '';
                            visibleFanCount++;
                        } else {
                            // Fan is not spinning (0 RPM), hide the card
                            fanCard.style.display = 'none';
                        }
                    } else {
                        // No sensor data available, show the card by default
                        fanCard.style.display = '';
                        visibleFanCount++;
                    }
                }
            }

            // Hide the entire fans section if no fans are visible
            const fansSection = document.getElementById('fans-section');
            if (fansSection) {
                if (visibleFanCount === 0) {
                    fansSection.style.display = 'none';
                } else {
                    fansSection.style.display = '';
                }
            }
        }
        // Main function to fetch and render sensor data from the API
        async function fetchAndRenderSensorData() {
            try {
                const response = await fetch('http://localhost:8085/data.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                // Extract hardware names from the API response (only on first run)
                if (!headersInitialized) {
                    extractHardwareNames(data);
                    updateSectionHeaders();
                }                // Generate CPU core sections dynamically (only on first run)
                if (!cpuCoresGenerated) {
                    generateCpuCoreSections(data);
                }

                // Generate fan sections dynamically (only on first run)
                if (!fansGenerated) {
                    generateFanSections(data);
                }                // Clear and re-flatten the data (only clear on first run or when needed)
                flattenSensors(data, Object.keys(flatSensorData).length === 0);

                // Initialize network interface mappings (only on first run)
                initializeNetworkMappings(data);

                // Batch DOM updates using requestAnimationFrame for better performance
                requestAnimationFrame(() => {
                    // Combine static and dynamic sensor mappings
                    const allSensorMappings = { ...sensorMapping, ...dynamicSensorMapping };

                    // Pre-filter mappings to only update elements that have changed
                    const updatesNeeded = [];

                    // Iterate through all sensor mappings (static + dynamic)
                    for (const htmlId in allSensorMappings) {
                        const config = allSensorMappings[htmlId];
                        const sensor = flatSensorData[config.apiId];

                        let value = NaN;
                        let barValue = NaN;

                        if (sensor && sensor.Value !== undefined) {
                            value = parseValue(sensor.Value);

                            // Apply parse factor if defined
                            if (config.parseFactor !== undefined) {
                                value *= config.parseFactor;
                            }

                            // Early check if value has changed significantly
                            const lastValue = targetValues.get(htmlId);
                            if (lastValue !== undefined && !isNaN(value) && Math.abs(lastValue - value) < 0.01) {
                                continue; // Skip this update
                            }

                            // Determine the maximum value for the progress bar
                            if (config.barMax !== undefined) {
                                barValue = config.barMax;
                            } else if (config.barApiId) {
                                const barSensor = flatSensorData[config.barApiId];
                                if (barSensor && barSensor.Value !== undefined) {
                                    barValue = parseValue(barSensor.Value);
                                    if (config.parseFactor !== undefined) {
                                        barValue *= config.parseFactor;
                                    }
                                }
                            } else if (sensor.Max !== undefined && config.type === 'Clock') {
                                // For clocks, use the Max value from the sensor data for bar scaling
                                barValue = parseValue(sensor.Max);
                                if (config.parseFactor !== undefined) {
                                    barValue *= config.parseFactor;
                                }
                            } else if (sensor.Max !== undefined) {
                                barValue = parseValue(sensor.Max);
                                if (config.parseFactor !== undefined) {
                                    barValue *= config.parseFactor;
                                }
                            }
                        }

                        // Queue update for processing
                        updatesNeeded.push({
                            htmlId,
                            value,
                            barValue,
                            formatter: config.formatter,
                            fixed: config.fixed
                        });
                    }                    // Process all queued updates
                    updatesNeeded.forEach(update => {
                        updateSensorUI(update.htmlId, update.value, update.barValue, update.formatter, update.fixed);
                    });

                    // Filter out fans with 0 RPM from visualization
                    filterZeroRpmFans();
                });

            } catch (error) {
                console.error("Error fetching or parsing sensor data:", error);
                // Reset all sensors on error
                requestAnimationFrame(() => {
                    const allSensorMappings = { ...sensorMapping, ...dynamicSensorMapping };
                    Object.keys(allSensorMappings).forEach(htmlId => {
                        const config = allSensorMappings[htmlId];
                        if (config.apiId) {
                            updateSensorUI(htmlId, NaN);
                        }
                    });
                });
            }
        }

        function formatUptime(seconds) {
            if (isNaN(seconds)) return '';
            const days = Math.floor(seconds / (3600 * 24));
            seconds %= (3600 * 24);
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            const secondsRemaining = Math.floor(seconds % 60);
            return `${days}d ${hours}h ${minutes}m ${secondsRemaining}s`;
        }        // Initialize the dashboard
        fetchAndRenderSensorData();

        interval_ms = 200
        let updateInterval = setInterval(fetchAndRenderSensorData, interval_ms);

        // Pause updates when page is not visible to save resources
        document.addEventListener('visibilitychange', function () {
            if (document.hidden) {
                clearInterval(updateInterval);
                console.log('Paused - page not visible');
            } else {
                updateInterval = setInterval(fetchAndRenderSensorData, interval_ms);
                console.log('Resumed - page visible');
                fetchAndRenderSensorData();
            }
        });
    </script>
</body>

</html>